#!/bin/bash
#
# ffmpeg-it - Wrapper to encode video files in the current directory and subdirectories using ffmpeg.
#
# Usage: ffmpeg-it INPUT_EXTENSION [INPUT_EXTENSION ...]
#                          [-o|--output-extension TARGET_EXTENSION]
#                          [-D|--delete]
#                          [-a|--acceleration[=DEVICE]]
#                          [-c|--codec CODEC]
#                          [--allstreams]
#                          [-s|--subscodec SUBSCODEC]
#                          [-r|--recursive[=MAXDEPTH]]
#                          [-v|--verbose VERBOSE_LEVEL]
#                          [-h|--help]
#                          -- [ffmpeg direct parameters]
#
# Options:
#   INPUT_EXTENSION:
#       Input video file extension. Can be a list of extensions, separated by white spaces.
#
#   -o, --output-extension TARGET_EXTENSION:
#       Target video file extension (default: same as source file).
#
#   -D, --delete:
#       Delete source files after encoding (default: false).
#
#   -a, --acceleration[=DEVICE]:
#       Enable hardware acceleration for encoding. Optionally specify the device render (default: the first available). 
#       Use ls /dev/dri/render* to check available renders.
#
#   -q, --quality QUALITY_VALUE:
#       Sets the quality Constant Rate Factor (CRF, CQP or similar). This is a integer value commonly between 0 and 51 (check codec docs). 
#
#   -c, --codec {h264|h265|none}:
#       Select the video codec. Options: h264, h265, none (default: none).
#
#   -s, --subscodec {dvdsub|none}:
#       Select the subtitle codec. Options: dvdsub, none (default: none).
#
#   --allstreams:
#       Encode all the available video, audio, subtitles and metadata streams. (default: false).
#
#   -r, --recursive[=MAXDEPTH]:
#       Search for video files recursively in subdirectories (default: false). Optionally specify the maximum depth to search.
#
#   --concatenate:
#       *Beta* option to concatenate all video inputs in the same output.mp4 file using h265 and crf 35 (compression).
#
#   --debug:
#       To just print the generated ffmpeg command and leave.
#
#   -v, --verbose VERBOSE_LEVEL:
#       Sets the verbose level. Options: quiet, panic, fatal, error, warning, info, verbose, debug, trace (default: warning). 
#
#   -h, --help:
#       Show this help message and exit.
#   
#   All arguments after -- are passed directly to ffmpeg.
#
# Description:
#   This script searches for video files in the current directory and subdirectories
#   with the specified input extensions, encodes them using ffmpeg, and saves the
#   encoded files with the specified output extension. Optionally, it can delete the
#   source files after encoding. Hardware acceleration using VAAPI can be enabled
#   with the -a or --acceleration option.
#
# Author: Guilherme Philippi <guilherme.philippi@hotmail.com>
# Date: March 2024

usage() {
  echo "Encode video files in the current directory using ffmpeg."
  echo "Usage: $0 INPUT_EXTENSION [INPUT_EXTENSION ...] [-o|--output-extension TARGET_EXTENSION] [-D|--delete] [-a|--acceleration[=DEVICE]] [-q|--quality QUALITY_VALUE] [-c|--codec {h264|h265|none}] [-s|--subscodec {dvdsub|none}] [--allstreams] [-r|--recursive[=MAXDEPTH]] [--concatenate] [--debug] [-v|--verbose VERBOSE_LEVEL] [-h|--help] -- [ffmpeg direct parameters]"
  exit 1
}

# Default values
debug=false
concatenate=false
same_extension=true
deleteSourceFile=false
enableAcceleration=false
verbose=24 #warning
quality=false
codec="none"
subscodec=()
allstreams=()
device=$(ls /dev/dri/render* | head -n1)
maxdepth=1 # recursive default as false

ffmpeg_args=()
extra_vf_filters=()
wrapper_args=()

# split between ffmpeg args (after --) and wrapper args (before --)
found_sep=false
for arg; do
  if [ "$arg" = "--" ] && [ "$found_sep" = false ]; then
    found_sep=true
    continue
  fi

  if [ "$found_sep" = true ]; then
    ffmpeg_args+=("$arg")
  else
    wrapper_args+=("$arg")
  fi
done

i=0
extra_vf_filters=()
temp_ffmpeg_args=()
while [ $i -lt ${#ffmpeg_args[@]} ]; do
  arg="${ffmpeg_args[$i]}"
  case "$arg" in
    -vf)
      ((i++))
      [ $i -ge ${#ffmpeg_args[@]} ] && {
        [ "$verbose" -ge 0 ] && echo -e "\033[31mError:\033[0m -vf requires an argument" >&2
        exit 1
      }
      extra_vf_filters+=("${ffmpeg_args[$i]}")
      ;;
    -vf=*)
      extra_vf_filters+=("${arg#*=}")
      ;;
    *)
      temp_ffmpeg_args+=("$arg")
      ;;
  esac

  ((i++))
done
ffmpeg_args=(${temp_ffmpeg_args[@]})
unset temp_ffmpeg_args

TEMP=$(getopt -o 'o:Da::q:c:s:d:r::v:h' --long 'output-extension:,delete,allstreams,acceleration::,quality::,codec:,subscodec:,device:,recursive::,verbose:,help,concatenate,debug' -n 'ffmpeg-it' -- "${wrapper_args[@]}")

if [ $? -ne 0 ]; then
  [ "$verbose" -ge 0 ] && echo -e "\033[31mError:\033[0m Failed parsing options." >&2
  usage
  exit 1
fi

eval set -- "$TEMP"
unset TEMP

while true; do
  case "$1" in
  '--debug')
    debug=true
    shift
    continue
    ;;
  '-o' | '--output-extension')
    same_extension=false
    outputExtension="$2"
    shift 2
    continue
    ;;
  '-D' | '--delete')
    deleteSourceFile=true
    shift
    continue
    ;;
  '--allstreams')
    allstreams=( -map 0 )
    shift
    continue
    ;;
  '-a' | '--acceleration')
    enableAcceleration=true
    case "$2" in
    '') ;;
    *)
      device="$2"
      ;;
    esac
    shift 2
    continue
    ;;
  '-q' | '--quality')
    quality=true
    quality_factor=$2
    shift 2
    continue
    ;;
  '-v' | '--verbose')
    case "$2" in
      'quiet')
        verbose=-8
        ;;
      'panic')
        verbose=0
        ;;
      'fatal')
        verbose=8
        ;;
      'error')
        verbose=16
        ;;
      'warning')
        verbose=24
        ;;
      'info')
        verbose=32
        ;;
      'verbose')
        verbose=40
        ;;
      'debug')
        verbose=48
        ;;
      'trace')
        verbose=56
        ;;
      *)
      device="$2"
      ;;
    esac
    shift 2
    continue
    ;;
  '-c' | '--codec')
    codec="$2"
    shift 2
    ;;
  '-s' | '--subscodec')
    if [ "$2" = "dvdsub" ]; then
      subscodec=( -c:s dvdsub )
    fi
    shift 2
    ;;
  '-r' | '--recursive')
    case "$2" in
    '')
      maxdepth=false
      ;;
    *)
      maxdepth="$2"
      ;;
    esac
    shift 2
    continue
    ;;
  '-h' | '--help')
    cat $0 | grep '#' | head -n 58 | tail -n 57 | cut -c2-
    exit 1
    ;;
  '--concatenate')
    concatenate=true
    shift 1
    ;;  
  '--')
    shift
    break
    ;;
  *)
    [ "$verbose" -ge 0 ] && echo -e "\033[31mError:\033[0m Untreated parameter $2" >&2
    usage
    exit 1
    ;;
  esac
done

if [ "$debug" = true ] && [ "$verbose" -ge 40 ]; then
  [ -n "$wrapper_args" ] && echo -e "\033[33mffmpeg-it args:\033[0m ${wrapper_args[@]}"
  [ -n "$ffmpeg_args" ] && echo -e "\033[33mffmpeg args:\033[0m ${ffmpeg_args[@]}"
  [ -n "$extra_vf_filters" ] && echo -e "\033[33mffmpeg vf extra args:\033[0m ${extra_vf_filters[@]}"
fi

if [ $# = 0 ]; then
  [ "$verbose" -ge 0 ] && echo -e "\033[31mError:\033[0m Input extensions not found." >&2
  usage
  exit 1
fi

# Setting Internal Field Separator to handle file names with spaces correctly
IFS=$'\n'
set -f

files=""
for extension; do
  if [ "$maxdepth" = false ]; then
    result=$(find . -type f -iname "*.$extension")
  else
    result=$(find . -maxdepth "$maxdepth" -type f -iname "*.$extension")
  fi
  if [ -n "$result" -a $? = 0 ]; then
    if [ -n "$files" ]; then
      files+=$'\n'"$result"
    else
      files+="$result"
    fi
  fi
done

files=$(echo "$files" | sort -V) # sort files by folders

if [ "$concatenate" = true ]; then # option to concatenate all inputs in the same .mp4 file.
  files="${files//'./'/"file '$(pwd)/"}"
  files="${files//".$extension"/".$extension'"}"
  ffmpeg -f concat -safe 0 -i <(echo "$files") -vcodec libx265 -crf 35 output.mp4
  exit 1
fi

for file in $files; do
  inputExtension="${file##*.}"
  
  if [ "$same_extension" = true ]; then
    outputExtension="$inputExtension"
  fi
  
  if [ "$inputExtension" = "$outputExtension" ]; then
    tag=1
    outputFile="${file%.*}-$tag.$outputExtension"
    while [ -e $outputFile ]; do
      tag=$(($tag+1)) # Will found the next file-tag name that is not used yet 
      outputFile="${file%.*}-$tag.$outputExtension"
    done
  else
    outputFile="${file%.*}.$outputExtension"
  fi

  [ "$verbose" -ge 0 ] && echo -e "\033[36mStarting\033[0m $file..."

  command=(
    ffmpeg
    -v "$verbose"
    -i "$file"
  )
  if [ "$verbose" -ge 0 ]; then
    command+=(-stats)
  else
    command+=(-nostats)
  fi

  if [ "$enableAcceleration" = true ]; then
    command+=(-vaapi_device "$device")
    base_vf="format=nv12,hwupload"
    if [ "$quality" = true ]; then
      command+=(-qp "$quality_factor")
    fi
    if [ "$codec" = "h264" ]; then
      command+=(
        -c:v h264_vaapi
      )
    elif [ "$codec" = "h265" ]; then
      command+=(
        -c:v hevc_vaapi
      )
    elif [ "$codec" = "none" ]; then
      [ "$verbose" -ge 24 ] && echo -e "\033[93mwarning:\033[0m hardware acceleration without specific codec" # TODO: is it possible to do it with hardware acceleration?
    fi
  else
    if [ "$quality" = true ]; then
      command+=(-crf "$quality_factor")
    fi
    if [ "$codec" = "h264" ]; then
      command+=(-c:v libx264)
    elif [ "$codec" = "h265" ]; then
      command+=(
        -c:v libx265 
        -x265-params log-level="$verbose"
      )
    fi
  fi

  cpu_filters=()
  vaapi_filters=()
  for f in "${extra_vf_filters[@]}"; do
    if [[ "$f" == *_vaapi* ]]; then
      vaapi_filters+=("$f")
    else
      cpu_filters+=("$f")
    fi
  done
  if [ "$verbose" -ge 40 ]; then
    [ -n "$vaapi_filters" ] && echo -e "\033[33mvaapi_filters args:\033[0m ${vaapi_filters[@]}"
    [ -n "$cpu_filters" ] && echo -e "\033[33mcpu_filters args:\033[0m ${cpu_filters[@]}"
  fi
  base_and_cpu_vf=($base_vf $cpu_filters)
  IFS=,
  vf="${cpu_filters:+${cpu_filters[*]}}${base_vf:+${cpu_filters:+,}$base_vf}${vaapi_filters:+${base_and_cpu_vf:+,}${vaapi_filters[*]}}"
  IFS=$'\n'
  if [ -n "$vf" ]; then
    command+=(-vf "$vf")
  fi

  command+=(
    ${allstreams:+"${allstreams[@]}"}
    ${subscodec:+"${subscodec[@]}"}
    ${ffmpeg_args:+"${ffmpeg_args[@]}"}
    "$outputFile"
  )

  if [ "$debug" = true ]; then
    print_cmd() {
      IFS=' '
      local out=()
      local arg
      for arg in "$@"; do
        out+=( "$(printf '%q' "$arg")" )
      done
      printf '%s\n' "${out[*]}"
      IFS=$'\n'
    }

    print_cmd "${command[@]}"
    continue
  fi

  "${command[@]}"

  if [ $? -ne 0 ]; then
    [ "$verbose" -ge 16 ] && echo -e "\033[31mError:\033[0m Failed to encode $file" >&2
    continue
  fi

  # Optionally delete the source file if "-D" flag is provided
  if [ "$deleteSourceFile" = true ]; then
    if [ -f "$outputFile" ]; then
      rm "$file"
      if [ "$inputExtension" = "$outputExtension" ]; then
        mv "$outputFile" "$file"
      fi
    else
      [ "$verbose" -ge 24 ] && echo -e "\033[93mwarning:\033[0m Output file don't created for $file. Pass the deletion to avoid file loss." >&2
    fi
  fi
done

# Resetting Internal Field Separator and file name generation
unset IFS
set +f
