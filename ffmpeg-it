#!/bin/bash
#
# ffmpeg-it - Wrapper to encode video files in the current directory and subdirectories using ffmpeg.
#
# Usage: ffmpeg-it INPUT_EXTENSION [INPUT_EXTENSION ...]
#                          [-o|--output-extension TARGET_EXTENSION]
#                          [-D|--delete]
#                          [-a|--acceleration[=DEVICE]]
#                          [-c|--codec CODEC]
#                          [-s|--subscodec SUBSCODEC]
#                          [-r|--recursive[=MAXDEPTH]]
#                          [--allstreams]
#                          [-l|--log]
#                          [-h|--help]
#                          -- [ffmpeg direct parameters]
#
# Options:
#   INPUT_EXTENSION:
#       Input video file extension. Can be a list of extensions, separated by white spaces.
#
#   -o, --output-extension TARGET_EXTENSION:
#       Target video file extension (default: same as source file).
#
#   -D, --delete:
#       Delete source files after encoding (default: false).
#
#   -a, --acceleration[=DEVICE]:
#       Enable hardware acceleration for encoding. Optionally specify the device render (default: the first available). 
#       Use ls /dev/dri/render* to check available renders.
#
#   -c, --codec {h264|h265|none}:
#       Select the video codec. Options: h264, h265, none (default: none).
#
#   -s, --subscodec {dvdsub|none}:
#       Select the subtitle codec. Options: dvdsub, none (default: none).
#
#   --allstreams:
#       Encode all the available video, audio, subtitles and metadata streams. (default: false).
#
#   -r, --recursive[=MAXDEPTH]:
#       Search for video files recursively in subdirectories (default: false). Optionally specify the maximum depth to search.
#
#   --concatenate:
#       *Beta* option to concatenate all video inputs in the same output.mp4 file using h265 and crf 35 (compression).
#
#   -h, --help:
#       Show this help message and exit.
#   
#   All arguments after -- are passed directly to ffmpeg.
#
# Description:
#   This script searches for video files in the current directory and subdirectories
#   with the specified input extensions, encodes them using ffmpeg, and saves the
#   encoded files with the specified output extension. Optionally, it can delete the
#   source files after encoding. Hardware acceleration using VAAPI can be enabled
#   with the -a or --acceleration option.
#
# Author: Guilherme Philippi <guilherme.philippi@hotmail.com>
# Date: March 2024

usage() {
  echo "Encode video files in the current directory using ffmpeg."
  echo "Usage: $0 INPUT_EXTENSION [INPUT_EXTENSION ...] [-o|--output-extension TARGET_EXTENSION] [-D|--delete] [-a|--acceleration[=DEVICE]] [-c|--codec {h264|h265|none}] [-s|--subscodec {dvdsub|none}] [--allstreams] [-r|--recursive[=MAXDEPTH]] [--concatenate] [-h|--help]"
  exit 1
}

# Default values
debug=false
concatenate=false
same_extension=true
deleteSourceFile=false
enableAcceleration=false
quality=()
codec="none"
subscodec=()
allstreams=()
device=$(ls /dev/dri/render* | head -n1)
maxdepth=1 # recursive default as false

ffmpeg_args=()
wrapper_args=()

# split between ffmpeg args (after --) and wrapper args (before --)
found_sep=false
for arg; do
  if [ "$arg" = "--" ] && [ "$found_sep" = false ]; then
    found_sep=true
    continue
  fi

  if [ "$found_sep" = true ]; then
    ffmpeg_args+=("$arg")
  else
    wrapper_args+=("$arg")
  fi
done

if [ "$debug" = true ]; then
  echo "ffmpeg-it args: ${wrapper_args[@]}"
  echo "ffmpeg args: ${ffmpeg_args[@]}"
fi

TEMP=$(getopt -o 'o:Da::q::c:s:d:r::h' --long 'debug,output-extension:,delete,allstreams,acceleration::,quality::,codec:,subscodec:,device:,recursive::,help,concatenate' -n 'ffmpeg-it' -- "${wrapper_args[@]}")
unset wrapper_args

if [ $? -ne 0 ]; then
  echo "Failed parsing options." >&2
  usage
  exit 1
fi

eval set -- "$TEMP"
unset TEMP

#TODO: -qp quality -vf video video filter
while true; do
  case "$1" in
  '--debug')
    debug=true
    shift
    continue
    ;;
  '-o' | '--output-extension')
    same_extension=false
    outputExtension="$2"
    shift 2
    continue
    ;;
  '-D' | '--delete')
    deleteSourceFile=true
    shift
    continue
    ;;
  '--allstreams')
    allstreams=( -map 0 )
    shift
    continue
    ;;
  '-a' | '--acceleration')
    enableAcceleration=true
    case "$2" in
    '') ;;
    *)
      device="$2"
      ;;
    esac
    shift 2
    continue
    ;;
  '-q' | '--quality')
    case "$2" in
    '') 
      quality=( -crf 0 )
      ;;
    *)
      quality=( -crf $2 )
      ;;
    esac
    shift 2
    continue
    ;;
  '-c' | '--codec')
    codec="$2"
    shift 2
    ;;
  '-s' | '--subscodec')
    subscodec="$2"
    if [ "$2" = "dvdsub" ]; then
      subscodec=( -c:s dvdsub )
    else
      subscodec=( "" )
    fi
    shift 2
    ;;
  '-r' | '--recursive')
    case "$2" in
    '')
      maxdepth=false
      ;;
    *)
      maxdepth="$2"
      ;;
    esac
    shift 2
    continue
    ;;
  '-h' | '--help')
    cat $0 | grep '#' | head -n 47 | tail -n 45 | cut -c2-
    exit 1
    ;;
  '--concatenate')
    concatenate=true
    shift 1
    ;;  
  '--')
    shift
    break
    ;;
  *)
    echo "Untreated parameter $2" >&2
    usage
    exit 1
    ;;
  esac
done

if [ $# = 0 ]; then
  echo "Error: Input extensions not found." >&2
  usage
  exit 1
fi

# Setting Internal Field Separator to handle file names with spaces correctly
IFS=$'\n'
set -f

files=""
for extension; do
  if [ "$maxdepth" = false ]; then
    result=$(find . -type f -iname "*.$extension")
  else
    result=$(find . -maxdepth "$maxdepth" -type f -iname "*.$extension")
  fi
  if [ -n "$result" -a $? = 0 ]; then
    if [ -n "$files" ]; then
      files+=$'\n'"$result"
    else
      files+="$result"
    fi
  fi
done

files=$(echo "$files" | sort -V) # sort files by folders

if [ "$concatenate" = true ]; then # option to concatenate all inputs in the same .mp4 file.
  files="${files//'./'/"file '$(pwd)/"}"
  files="${files//".$extension"/".$extension'"}"
  ffmpeg -f concat -safe 0 -i <(echo "$files") -vcodec libx265 -crf 35 output.mp4
  exit 1
fi

for file in $files; do
  inputExtension="${file##*.}"
  
  if [ "$same_extension" = true ]; then
    outputExtension="$inputExtension"
  fi
  
  if [ "$inputExtension" = "$outputExtension" ]; then
    tag=1
    outputFile="${file%.*}-$tag.$outputExtension"
    while [ -e $outputFile ]; do
      tag=$(($tag+1)) # Will found the next file-tag name that is not used yet 
      outputFile="${file%.*}-$tag.$outputExtension"
    done
  else
    outputFile="${file%.*}.$outputExtension"
  fi

  echo "Starting $file..."

  command=(
    ffmpeg
    -v error
    -stats
    -i "$file"
  )
  if [ "$enableAcceleration" = true ]; then
    command+=(
      -vaapi_device "$device"
    )
    if [ "$codec" = "h264" ]; then
      command+=(
        -c:v h264_vaapi
        -vf 'format=nv12|vaapi,hwupload'
      )
    elif [ "$codec" = "h265" ]; then
      command+=(
        -c:v hevc_vaapi
        -vf 'format=nv12|vaapi,hwupload'
      )
    elif [ "$codec" = "none" ]; then
      echo -e "\033[93mwarning:\033[0m hardware acceleration without specific codec" # TODO: is it possible to do it with hardware acceleration?
    fi
  else
    if [ "$codec" = "h264" ]; then
      command+=(-c:v libx264)
    elif [ "$codec" = "h265" ]; then
      command+=(
        -c:v libx265 
        -x265-params log-level=error
      )
    fi
  fi
  command+=(
    "${allstreams[@]}"
    "${subscodec[@]}"
    "${quality[@]}"
    "${ffmpeg_args[@]}"
    "$outputFile"
  )

  if [ "$debug" = true ]; then
    echo "ffmpeg command: ${command[@]}"
    exit 1
  fi

  "${command[@]}"

  if [ $? -ne 0 ]; then
    echo "Error: Failed to encode $file"
    continue
  fi

  # Optionally delete the source file if "-D" flag is provided
  if [ "$deleteSourceFile" = true ]; then
    if [ -f "$outputFile" ]; then
      rm "$file"
      if [ "$inputExtension" = "$outputExtension" ]; then
        mv "$outputFile" "$file"
      fi
    else
      echo "Error: Output file don't created for $file. Pass the deletion to avoid file loss." >&2
    fi
  fi
done

# Resetting Internal Field Separator and file name generation
unset IFS
set +f
